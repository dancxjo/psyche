#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
DEFAULT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd -P)"
if [ -n "${PSY_ROOT:-}" ] && [ -d "${PSY_ROOT%/}/provision/services" ]; then
  ROOT="${PSY_ROOT%/}"
elif [ -d "${DEFAULT_ROOT}/provision/services" ]; then
  ROOT="$DEFAULT_ROOT"
elif [ -d "/opt/psyched/provision/services" ]; then
  ROOT="/opt/psyched"
else
  ROOT="${DEFAULT_ROOT}"
fi
export PSY_ROOT="$ROOT"
PROV="$ROOT/provision"
HOSTCFG_DIR="$PROV/hosts"
SVCDIR="$PROV/services"
WS="$ROOT/ws"
. "$SVCDIR/_common.sh" 2>/dev/null || true

# Merge helper: consolidate legacy /opt/ros2_ws into $WS and replace with symlink.
# Idempotent: if /opt/ros2_ws is already a symlink pointing at $WS, nothing happens.
merge_legacy_workspace() {
  LEGACY="/opt/ros2_ws"
  TARGET="$WS"
  # Already a symlink pointing to target? Done.
  if [ -L "$LEGACY" ]; then
    local dest
    dest="$(readlink -f "$LEGACY" 2>/dev/null || true)"
    if [ "$dest" = "$TARGET" ]; then
      return 0
    else
      echo "[psy][merge] NOTE: $LEGACY is a symlink to $dest (not $TARGET). Skipping auto-merge." >&2
      return 0
    fi
  fi
  # If legacy doesn't exist, nothing to do.
  [ -e "$LEGACY" ] || return 0
  # Ensure target src exists.
  mkdir -p "$TARGET/src"
  if [ -d "$LEGACY/src" ]; then
    echo "[psy][merge] Consolidating packages from $LEGACY/src into $TARGET/src"
    for pkg in "$LEGACY"/src/*; do
      [ -d "$pkg" ] || continue
      name="$(basename "$pkg")"
      if [ -e "$TARGET/src/$name" ]; then
        echo "[psy][merge]   - skip existing $name"
      else
        echo "[psy][merge]   - move $name"
        mv "$pkg" "$TARGET/src/" 2>/dev/null || {
          echo "[psy][merge]   ! WARN: could not move $name (permissions?)" >&2
        }
      fi
    done
  fi
  # Backup legacy directory and replace with symlink (only if still a real dir)
  if [ ! -L "$LEGACY" ]; then
    ts="$(date +%Y%m%d-%H%M%S)"
    backup="${LEGACY}.bak.${ts}"
    echo "[psy][merge] Backing up $LEGACY to $backup and creating symlink -> $TARGET"
    mv "$LEGACY" "$backup" 2>/dev/null || {
      echo "[psy][merge] WARN: failed to rename $LEGACY (permissions?) - aborting symlink step" >&2
      return 0
    }
    ln -s "$TARGET" "$LEGACY" 2>/dev/null || {
      echo "[psy][merge] ERROR: failed to create symlink $LEGACY -> $TARGET" >&2
      return 1
    }
  fi
}

usage() {
  cat <<USAGE
psy — psycheOS host/service manager

Usage:
  psy bring up [svc..]        Start named services via systemd (defaults to all)
  psy bring down [svc..]      Stop named services via systemd (defaults to all)
  psy bring restart [svc..]   Restart named services via systemd (defaults to all)
  psy bring status [svc..]    Show brief status for named services (defaults to all)
  psy debug [svc..]           Show systemd summary plus recent logs
  psy host apply [<host>]      Apply host's service set (defaults to $(hostname))
  psy svc list                 List available services
  psy svc enable <name>        Enable a service for this host
  psy svc disable <name>       Disable a service for this host
  psy build                    colcon build (creates ws if needed)
  psy bringup nav              Launch nav2 stack (tmux/screen-less; use systemd)
  psy bringup create           Launch iRobot Create base bringup (create_bringup create_1.launch)
  psy systemd install          Install per-service systemd units and enable configured ones
  psy systemd info [svc..]    Show systemd summary (and recent logs for named services)
  psy systemd up               Start all enabled service units now
  psy systemd down             Stop all service units
  psy update                   Reinstall latest psyche from GitHub and re-apply
  psy say <text>               Publish text to /voice/$(hostname -s)

Helper:
  psh say <text>               Convenience wrapper to publish to /voice/$(hostname -s)
  psh bearing <deg>            Publish /cmd_vel Twist to rotate toward the bearing
USAGE
}

list_launch_services() {
  if compgen -G "/etc/psyched/*.launch.sh" >/dev/null; then
    for f in /etc/psyched/*.launch.sh; do
      [ -e "$f" ] || continue
      local base
      base="$(basename "$f")"
      printf '%s\n' "${base%.launch.sh}"
    done
    return 0
  fi
  return 1
}

resolve_service_names() {
  if [ $# -gt 0 ]; then
    for svc in "$@"; do
      [ -n "$svc" ] || continue
      printf '%s\n' "$svc"
    done
    return 0
  fi

  if list_launch_services; then
    return 0
  fi

  systemctl list-unit-files 'psyched@*.service' --no-legend 2>/dev/null \
    | awk '$1 ~ /^psyched@.+\.service$/ { sub(/^psyched@/, "", $1); sub(/\.service$/, "", $1); if (!seen[$1]++) print $1 }'
}

systemd_info() {
  echo "[psy] systemctl summary (filtered)"
  systemctl --no-pager | grep -i "psych" || true
  if [ $# -gt 0 ]; then
    for s in "$@"; do
      printf "\n[psy] recent logs for psyched@%s.service\n" "$s"
      sudo journalctl -u "psyched@${s}.service" -n 200 --no-pager -o short-precise || true
      systemctl status "psyched@${s}.service" --no-pager -l | sed -n '1,5p' || true
    done
  fi
}

host_cfg() { echo "${HOSTCFG_DIR}/${1}.toml"; }

get_host() { echo "${1:-$(hostname)}"; }

toml_get_array() { # robust: extract quoted entries from an array, ignore comments
  # arg1=file arg2=key
  awk -v k="$2" '
    BEGIN{ inarr=0 }
    $0 ~ "^[[:space:]]*"k"[[:space:]]*=" { inarr=1 }
    inarr {
      line=$0
      # strip comments
      sub(/#.*/, "", line)
      # find quoted strings and print each
      while (match(line, /"([^"]+)"/, m)) {
        print m[1]
        line=substr(line, RSTART+RLENGTH)
      }
      if ($0 ~ /\]/) { exit }
    }
  ' "$1"
}

cmd="${1:-}"; shift || true
case "$cmd" in
  update)
    echo "[psy] Updating psyche (this may take 5-45 minutes). Do not cancel."
    if [ -x "$ROOT/tools/install.sh" ]; then
      sudo bash "$ROOT/tools/install.sh"
    else
      echo "[psy] ERROR: installer not found at $ROOT/tools/install.sh" >&2
      exit 1
    fi
    ;;
  host)
    sub="${1:-}"; shift || true
    case "$sub" in
      apply)
        HOST="$(get_host "${1:-}")"
        CFG="$(host_cfg "$HOST")"
        [ -f "$CFG" ] || { echo "No host config: $CFG" >&2; exit 1; }
        mapfile -t SERVICES < <(toml_get_array "$CFG" "services")
        export PSY_HOST_FILE="$CFG"
        export PSY_DEFER_APT=1
        for s in "${SERVICES[@]}"; do
          echo "[psy] apply service: $s"
          bash "$SVCDIR/$s.sh" provision
        done
        # Perform one apt-get install for all queued packages
        common_flush_apt_queue || true
        echo "[psy] Performing one workspace build after provisioning all services"
        bash "$SVCDIR/workspace.sh" build || true
        echo "[psy] Installing systemd units and enabling those with launchers"
        bash "$PROV/systemd/install_units.sh" || true
        # Start all services that have launchers present, regardless of enablement status
        echo "[psy] Starting services with launchers in /etc/psyched"
        if compgen -G "/etc/psyched/*.launch.sh" >/dev/null; then
          mapfile -t START_SVCS < <(for f in /etc/psyched/*.launch.sh; do [ -e "$f" ] || continue; b=$(basename "$f"); echo "${b%.launch.sh}"; done)
          if [ ${#START_SVCS[@]} -gt 0 ]; then
            for s in "${START_SVCS[@]}"; do
              echo "  -> sudo systemctl start psyched@${s}.service"
              sudo systemctl start "psyched@${s}.service" || true
            done
          fi
        else
          echo "[psy] No launchers found at /etc/psyched/*.launch.sh yet"
        fi
        ;;
      *) usage; exit 1;;
    esac
    ;;
  svc)
    sub="${1:-}"; shift || true
    case "$sub" in
      list)
        (cd "$SVCDIR" && ls -1 *.sh | sed 's/\.sh$//')
        ;;
      enable|disable)
        HOST="$(get_host)"
        CFG="$(host_cfg "$HOST")"
        NAME="${1:?service name}"
        tmp="$(mktemp)"
        if [ "$sub" = "enable" ]; then
          awk -v n="$NAME" '
            BEGIN{done=0}
            /^services[[:space:]]*=/ {print; inarr=1; next}
            inarr {
              if ($0 ~ /\]/ && done==0) { sub(/\]/,", \"" n "\" ]"); done=1 }
              print; if ($0 ~ /\]/) {inarr=0} ; next
            }
            {print}
            END{ if(done==0) print "services = [ \"" n "\" ]" }
          ' "$CFG" > "$tmp"
        else
          awk -v n="$NAME" '
            /^services[[:space:]]*=/ {print; inarr=1; next}
            inarr {
              gsub("\"" n "\"","")
              gsub(/,,/,",")
              gsub(/\[ *\]/,"[ ]")
              print
              if ($0 ~ /\]/) inarr=0
              next
            }
            {print}
          ' "$CFG" > "$tmp"
        fi
        mv "$tmp" "$CFG"
        echo "[psy] $sub $NAME on $HOST"
        ;;
      *) usage; exit 1;;
    esac
    ;;
  build)
    mkdir -p "$WS/src"
    # Perform one-time merge of legacy /opt/ros2_ws if present
    merge_legacy_workspace || true
    # If any packages were queued, install them now
    common_flush_apt_queue || true
    bash "$SVCDIR/workspace.sh" build
    ;;
  bringup)
    sub="${1:-}"; shift || true
    case "$sub" in
      nav)
        echo "[psy] 'psy bringup nav' is deprecated; use 'psy bring up nav'"
        "$0" bring up nav
        ;;
      create)
        echo "[psy] launching Create base bringup (create_bringup create_1.launch)"
        # Prefer dedicated bringup script if present (kept in provision/bringup)
        if [ -x "$PROV/bringup/create.sh" ]; then
          exec "$PROV/bringup/create.sh" "$@"
        fi
        # Fallback: manually source environments and launch
        set +u; [ -f "/opt/ros/${ROS_DISTRO:-jazzy}/setup.bash" ] && source "/opt/ros/${ROS_DISTRO:-jazzy}/setup.bash"; set -u
        set +u; [ -f "$WS/install/setup.bash" ] && source "$WS/install/setup.bash"; set -u
        exec ros2 launch create_bringup create_1.launch "$@"
        ;;
      *) usage; exit 1;;
    esac
    ;;
  bring)
    action="${1:-}"; shift || true
    case "$action" in
      up|start)
        mapfile -t SERVICES < <(resolve_service_names "$@")
        if [ ${#SERVICES[@]} -eq 0 ]; then
          echo "[psy] No services found to start"
        else
          UNITS=()
          for svc in "${SERVICES[@]}"; do
            UNITS+=("psyched@${svc}.service")
          done
          echo "[psy] Starting services: ${SERVICES[*]}"
          sudo systemctl start "${UNITS[@]}" || true
        fi
        ;;
      down|stop)
        mapfile -t SERVICES < <(resolve_service_names "$@")
        if [ ${#SERVICES[@]} -eq 0 ]; then
          echo "[psy] No services found to stop"
        else
          UNITS=()
          for svc in "${SERVICES[@]}"; do
            UNITS+=("psyched@${svc}.service")
          done
          echo "[psy] Stopping services: ${SERVICES[*]}"
          sudo systemctl stop "${UNITS[@]}" || true
        fi
        ;;
      restart)
        mapfile -t SERVICES < <(resolve_service_names "$@")
        if [ ${#SERVICES[@]} -eq 0 ]; then
          echo "[psy] No services found to restart"
        else
          UNITS=()
          for svc in "${SERVICES[@]}"; do
            UNITS+=("psyched@${svc}.service")
          done
          echo "[psy] Restarting services: ${SERVICES[*]}"
          sudo systemctl restart "${UNITS[@]}" || true
        fi
        ;;
      status)
        mapfile -t SERVICES < <(resolve_service_names "$@")
        if [ ${#SERVICES[@]} -eq 0 ]; then
          echo "[psy] No services found"
        else
          for svc in "${SERVICES[@]}"; do
            systemctl status "psyched@${svc}.service" --no-pager -l | sed -n '1,5p' || true
          done
        fi
        ;;
      *)
        usage
        exit 1
        ;;
    esac
    ;;
  systemd)
    sub="${1:-}"; shift || true
    case "$sub" in
      install) bash "$PROV/systemd/install_units.sh" ;;
      info)
        systemd_info "$@"
        ;;
      up)
        mapfile -t SERVICES < <(resolve_service_names "$@")
        if [ ${#SERVICES[@]} -eq 0 ]; then
          echo "[psy] No psyched@*.service unit files installed"
        else
          UNITS=()
          for svc in "${SERVICES[@]}"; do
            UNITS+=("psyched@${svc}.service")
          done
          sudo systemctl start "${UNITS[@]}" || true
        fi
        ;;
      down)
        mapfile -t SERVICES < <(resolve_service_names "$@")
        if [ ${#SERVICES[@]} -eq 0 ]; then
          echo "[psy] No running psyched@*.service units"
        else
          UNITS=()
          for svc in "${SERVICES[@]}"; do
            UNITS+=("psyched@${svc}.service")
          done
          sudo systemctl stop "${UNITS[@]}" || true
        fi
        ;;
      *) usage; exit 1;;
    esac
    ;;
  debug)
    systemd_info "$@"
    ;;
  bearing)
    # Publish a geometry_msgs/msg/Twist command that mirrors the proportional
    # turning logic in psyche_vision/object_controller.py.
    gain="${PSH_BEARING_GAIN:-2.0}"
    max_ang="${PSH_BEARING_MAX_ANGULAR:-0.5}"
    tolerance="${PSH_BEARING_TOLERANCE:-2.0}"
    topic="${PSH_BEARING_TOPIC:-/cmd_vel}"
    dry_run=0
    bearing_arg=""
    while [ $# -gt 0 ]; do
      case "$1" in
        -g|--gain)
          [ $# -ge 2 ] || { echo "[psy][bearing] ERROR: --gain requires a value" >&2; exit 1; }
          gain="$2"
          shift 2
          ;;
        -m|--max)
          [ $# -ge 2 ] || { echo "[psy][bearing] ERROR: --max requires a value" >&2; exit 1; }
          max_ang="$2"
          shift 2
          ;;
        -t|--tolerance)
          [ $# -ge 2 ] || { echo "[psy][bearing] ERROR: --tolerance requires a value" >&2; exit 1; }
          tolerance="$2"
          shift 2
          ;;
        --topic)
          [ $# -ge 2 ] || { echo "[psy][bearing] ERROR: --topic requires a name" >&2; exit 1; }
          topic="$2"
          shift 2
          ;;
        --dry-run)
          dry_run=1
          shift
          ;;
        -h|--help)
          cat <<'HELP'
Usage: psy bearing [options] <bearing_degrees>

Options:
  -g, --gain <float>         Override proportional gain (default PSH_BEARING_GAIN or 2.0)
  -m, --max <float>          Override max angular velocity in rad/s (default PSH_BEARING_MAX_ANGULAR or 0.5)
  -t, --tolerance <float>    Override deadzone tolerance in degrees (default PSH_BEARING_TOLERANCE or 2.0)
      --topic <name>         Publish to a different Twist topic (default PSH_BEARING_TOPIC or /cmd_vel)
      --dry-run              Print the computed command without invoking ros2
HELP
          exit 0
          ;;
        --)
          shift
          while [ $# -gt 0 ]; do
            if [ -n "$bearing_arg" ]; then
              echo "[psy][bearing] ERROR: multiple bearing values provided ($bearing_arg, $1)" >&2
              exit 1
            fi
            bearing_arg="$1"
            shift
          done
          ;;
        -* )
          if [ -z "$bearing_arg" ] && [[ "$1" =~ ^-?[0-9]+([.][0-9]+)?$ ]]; then
            bearing_arg="$1"
            shift
          else
            echo "[psy][bearing] ERROR: unknown option $1" >&2
            exit 1
          fi
          ;;
        *)
          if [ -n "$bearing_arg" ]; then
            echo "[psy][bearing] ERROR: multiple bearing values provided ($bearing_arg, $1)" >&2
            exit 1
          fi
          bearing_arg="$1"
          shift
          ;;
      esac
    done
    if [ -z "$bearing_arg" ]; then
      echo "[psy][bearing] ERROR: bearing degrees argument is required." >&2
      exit 1
    fi

    if ! calc_output="$(python3 - "$bearing_arg" "$gain" "$max_ang" "$tolerance" <<'PY'
import math
import sys

PREFIX = "[psy][bearing]"

def fail(message: str) -> None:
    print(f"{PREFIX} ERROR: {message}", file=sys.stderr)
    sys.exit(2)

if len(sys.argv) < 5:
    fail("internal argument parsing error (missing computation parameters).")

try:
    bearing = float(sys.argv[1])
except ValueError:
    fail("bearing must be a valid number of degrees.")
except IndexError:
    fail("bearing argument missing.")

try:
    gain = float(sys.argv[2])
    max_ang = float(sys.argv[3])
    tolerance = float(sys.argv[4])
except ValueError:
    fail("gain, max angular velocity, and tolerance must be numeric.")

if math.isnan(bearing) or math.isinf(bearing):
    fail("bearing must be finite.")

for label, value, allow_zero in (
    ("proportional gain", gain, False),
    ("max angular velocity", max_ang, False),
    ("angle tolerance", tolerance, True),
):
    if math.isnan(value) or math.isinf(value):
        fail(f"{label} must be finite.")
    if allow_zero:
        if value < 0.0:
            fail(f"{label} must be greater than or equal to zero.")
    else:
        if value <= 0.0:
            fail(f"{label} must be greater than zero.")

within_tol = abs(bearing) < tolerance
raw = 0.0
clamped = False
if within_tol:
    value = 0.0
else:
    raw = gain * math.radians(bearing)
    value = raw
    if value > max_ang:
        value = max_ang
        clamped = True
    elif value < -max_ang:
        value = -max_ang
        clamped = True

if abs(value) < 1e-9:
    value = 0.0

print(f"{value:.6f}")
print(f"{bearing:.6f}")
print("1" if within_tol else "0")
print("1" if clamped else "0")
print(f"{raw:.6f}")
PY
)"; then
      status=$?
      exit $status
    fi

    mapfile -t _calc <<< "$calc_output"
    angular="${_calc[0]:-0}"
    bearing_fmt="${_calc[1]:-0}"
    within_tol="${_calc[2]:-0}"
    clamped="${_calc[3]:-0}"

    printf -v bearing_disp "%.2f" "$bearing_fmt"
    printf -v angular_disp "%.6f" "$angular"
    printf -v tol_disp "%.2f" "$tolerance"
    printf -v gain_disp "%.2f" "$gain"
    printf -v max_disp "%.2f" "$max_ang"

    if [ "$within_tol" = "1" ]; then
      echo "[psy][bearing] bearing=${bearing_disp}° within tolerance ${tol_disp}° — publishing stop command to ${topic} (angular.z=${angular_disp})"
    else
      if [ "$clamped" = "1" ]; then
        echo "[psy][bearing] bearing=${bearing_disp}° -> angular.z=${angular_disp} rad/s (clamped to ±${max_disp} rad/s; gain=${gain_disp}) on ${topic}"
      else
        echo "[psy][bearing] bearing=${bearing_disp}° -> angular.z=${angular_disp} rad/s (gain=${gain_disp}, max=${max_disp}) on ${topic}"
      fi
    fi

    printf -v twist_msg "{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: %s}}" "$angular_disp"

    if [ "$dry_run" = "1" ]; then
      echo "[psy][bearing] Dry run requested; not publishing to ${topic}"
      exit 0
    fi

    if ! command -v ros2 >/dev/null 2>&1; then
      set +u; source /opt/ros/${ROS_DISTRO:-jazzy}/setup.bash 2>/dev/null || true; set -u
    fi
    if ! command -v ros2 >/dev/null 2>&1; then
      echo "[psy][bearing] ERROR: ros2 CLI not found (install or source environment)." >&2
      exit 2
    fi

    ros2 topic pub --once "$topic" geometry_msgs/msg/Twist "$twist_msg" || {
      echo "[psy][bearing] ERROR: failed to publish Twist message on ${topic}" >&2
      exit 3
    }
    ;;
  say)
    # Publish a message to voice topic
    if [ $# -eq 0 ]; then
      echo "Usage: psy say <text>" >&2
      exit 1
    fi
    if ! command -v ros2 >/dev/null 2>&1; then
      set +u; source /opt/ros/${ROS_DISTRO:-jazzy}/setup.bash 2>/dev/null || true; set -u
    fi
    if ! command -v ros2 >/dev/null 2>&1; then
      echo "[psy] ERROR: ros2 CLI not found (install or source environment)." >&2
      exit 2
    fi
    host_short="$(hostname -s)"
    topic="/voice/${host_short}"
    msg="$*"
    # Escape for YAML inline string
    msg_esc="${msg//\\/\\\\}"
    msg_esc="${msg_esc//\"/\\\"}"
    ros2 topic pub --once "$topic" std_msgs/String "{data: \"$msg_esc\"}" || {
      echo "[psy] ERROR: failed to publish to $topic" >&2
      exit 3
    }
    ;;
  *) usage; exit 1;;
esac
